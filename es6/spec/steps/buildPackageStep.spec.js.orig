import buildPackageStep from "../../lib/steps/buildPackageStep.js";
import sinon from "sinon";
import fileSystem from "fs";
import path from "path";
import temp from "temp";
import unzip from "unzip2";
import inflect from "jargon";
import glob from "glob";

temp.track();

describe(".buildPackageStep(conan, context, stepDone)", () => {
<<<<<<< Updated upstream
	let conan,
=======
	let mockConan,
>>>>>>> Stashed changes
			context,

<<<<<<< Updated upstream
			lambdaResponseError,
			lambdaResponseData,

			s3ResponseError,
			s3ResponseData,

			stepReturnError,
			stepReturnData,

			conanAwsLambda,

			mockLambdaSpy,
			mockS3Spy,
=======
			mockLambda,

			akiroConstructorSpy,
			mockAkiro;
>>>>>>> Stashed changes


<<<<<<< Updated upstream
	const mockS3GetObjectRequest = {
		createReadStream: () => {
			return fileSystem.createReadStream(__dirname + "/../fixtures/packages.zip");
		}
	};

	const mockS3 = {
		getObject: sinon.spy(() => {
			return mockS3GetObjectRequest;
		})
	};

	class MockS3 {
		constructor(config) {
			mockS3Spy(config);
			return mockS3;
		}
	}

	const mockLambda = {
		invoke: sinon.spy((params, callback) => {
			callback(lambdaResponseError, lambdaResponseData);
		})
	};

	class MockLambda {
		constructor(config) {
			mockLambdaSpy(config);
			return mockLambda;
		}
	}

	const MockAWS = {
		S3: MockS3,
		Lambda: MockLambda
	};

	beforeEach(done => {
		conan = new Conan({
			region: "us-east-1",
			bucket: "some-bucket-here"
		});

		const lambdaName = "TestFunction";

		packageZipFileName = `${inflect(lambdaName).camel.toString()}.packages.zip`;

		packages = { "async": "1.0.0" };

		conanAwsLambda = new class MockConanAwsLambda {
			name() { return lambdaName; }
			packages() { return packages; }
		}();

		mockLambdaSpy = sinon.spy();
		mockS3Spy = sinon.spy();

		temp.mkdir("compilePackages", (error, temporaryDirectoryPath) => {
			context = {
				temporaryDirectoryPath: temporaryDirectoryPath,
				parameters: conanAwsLambda,
				libraries: { AWS: MockAWS },
				results: {}
			};

			// "Lambda Found" response by default
			lambdaResponseData = {};
			lambdaResponseError = null;

			stepDone = (afterStepCallback) => {
				return (callbackError, data) => {
					stepReturnError = callbackError;
					stepReturnData = data;
					afterStepCallback();
=======
	class MockAkiro {
		constructor(...options) {
			akiroConstructorSpy(...options);
			return mockAkiro;
		}
	}

	beforeEach(() => {
		mockConan = {
			config: {
				region: "us-east-1",
				bucket: "my-bucket"
			}
		};

		mockLambda = {
			name: () => { return "MyLambda"; }
		};

		mockAkiro = {
			package: sinon.spy((packages, outputDirectory, packageCallback) => {
				fileSystem.mkdirSync(outputDirectory);
				packageCallback();
			})
		};

		akiroConstructorSpy = sinon.spy();

		context = {
			temporaryDirectoryPath: temp.mkdirSync("buildPackageStep"),
			libraries: {
				Akiro: MockAkiro
			},
			parameters: mockLambda
		};
	});

	describe("(when .packages() are set)", () => {
		beforeEach(done => {
			mockLambda.packages = () => {
				return {
					flowsync: "0.1.12",
					incognito: "0.1.4"
>>>>>>> Stashed changes
				};
			};
			buildPackageStep(mockConan, context, stepDone(done));
		});

		it("should configure akiro with the designated options", () => {
			akiroConstructorSpy.calledWith({
				region: mockConan.config.region,
				bucket: mockConan.config.bucket
			}).should.be.true;
		});

		it("should call akiro.package with the specified packages", () => {
			mockAkiro.package.calledWith(mockLambda.packages()).should.be.true;
		});

<<<<<<< Updated upstream
	describe("(When packages are set to be compiled)", () => {
		it("should set the designated region on the lambda client", () => {
			mockLambdaSpy.calledWith({
				region: conan.config.region
			}).should.be.true;
		});

		it("should set the designated region on the s3 client", () => {
			mockS3Spy.calledWith({
				region: conan.config.region
			}).should.be.true;
		});

		it("should call AWS with the designated lambda parameters", () => {
			mockLambda.invoke.firstCall.args[0].should.eql({
				FunctionName: "Thaumaturgy",
				InvocationType: "RequestResponse",
				LogType: "Tail",
				Payload: JSON.stringify({
					packages: conanAwsLambda.packages(),
					bucket: conan.config.bucket,
					key: packageZipFileName
				})
			});
		});

		it("should call AWS with the designated S3 parameters", () => {
			mockS3.getObject.firstCall.args[0].should.eql({
				Bucket: conan.config.bucket,
				Key: packageZipFileName
			});
		});

		it("should have all package files within the package zip", done => {
			/* eslint-disable new-cap */
=======
		it("should return the package zip file path", () => {
			const expectedPackageZipFilePath = `${context.temporaryDirectoryPath}/zip/${inflect(mockLambda.name()).camel.toString()}.packages.zip`;
			stepReturnData.should.eql({
				packageZipFilePath: expectedPackageZipFilePath
			});
		});

		it("should generate a zip file containing all of the built packages at the package zip file path", done => {
			const expectedPackageZipFilePath = `${context.temporaryDirectoryPath}/zip/${inflect(mockLambda.name()).camel.toString()}.packages.zip`;
			const expectedFilePaths = glob.sync(`${context.temporaryDirectoryPath}/zip/`);

>>>>>>> Stashed changes
			let zipFilePaths = [];

			fileSystem.createReadStream(expectedPackageZipFilePath)
				.pipe(unzip.Parse())
				.on("entry", entry => {
					zipFilePaths.push(entry.path);
				})
				.on("close", () => {
					zipFilePaths.should.have.members(expectedFilePaths);
					done();
				});
		});
	});

	describe("(when .packages() are NOT set)", () => {
		beforeEach(done => {
			mockLambda.packages = () => {};
			buildPackageStep(mockConan, context, stepDone(done));
		});

		it("should return with the package zip file path set to null", () => {
			stepReturnData.should.eql({
				packageZipFilePath: null
			});
		});
	});
});

/* SPEC UTILITIES BELOW HERE */

let stepReturnError;
let stepReturnData;

function stepDone (done) {
	return (error, data) => {
		stepReturnError = error;
		stepReturnData = data;
		done();
	};
}
